<!DOCTYPE html>
<html>

    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <meta name="citation_title" content="Using SPARQL to access Linked Open Data" />

<meta name="citation_author" content="Matthew Lincoln" />

<meta name="citation_publication_date" content="2015-11-24" />
<meta name="citation_journal_title" content="Programming Historian" />
<meta name="citation_public_url" content="http://programminghistorian.org/lessons/graph-databases-and-SPARQL" />


    <!-- Mobile viewport optimized: h5bp.com/viewport -->
    <meta name="viewport" content="width=device-width">
    
    <!--Font awesome CDN -->
    <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

    <link href='http://fonts.googleapis.com/css?family=Lato:300,700%7CCrete+Round' rel='stylesheet' type='text/css'>
    <link href="../css/style.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/github.css">
    <link href='../feed.xml.rss' rel='alternate' type='application/atom+xml'>
    <title>Using SPARQL to access Linked Open Data | Programming Historian</title>
        
    <script src="http://code.jquery.com/jquery-latest.min.js" type="text/javascript"></script>
    <script type="text/javascript" src="../js/ui.js"></script>
    <script type="text/javascript" src="../js/ext_links.js"></script>
    <script type="text/javascript" src="../js/header_links.js"></script>
    <script>
      $(document).ready(function(){
        $('.slide-trigger').collapsable();
      });
    </script>

    <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-2752866-8']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


  </head>



  
  
  

  <body>

    <header role="banner">
    <h1><a href="../index.html">The Programming Historian</a></h1>

	        <div class="additional">
          <ul id="menu-main-menu" class="additional">
            <li class="menu-item"><a href="../index.html">About</a></li>
            <li class="menu-item"><a href="index.html">Lessons</a></li>
            <li class="menu-item"><a href="../contribute.html">Contribute</a></li>
            <li class="menu-item"><a href="../project-team.html">Project Team</a></li>
            <li class="menu-item"><a href="../blog.html">Blog</a></li>
          </ul>
        </div>

	</header>

	<div role="main">
		<article>
			<header>

                
				
			    <p class="kicker">November 24, 2015</p>
				<h1><a href="graph-databases-and-SPARQL.html">Using SPARQL to access Linked Open Data</a></h1>
                <p class="byline">By 
  
        Matthew Lincoln
  
  </p>

				
				
				<ul class="credits">Reviewed by
				
                      
                           
                                 Patrick Murray-John
                           
                      
                           
						         , Jason Heppler
                           
                      
                           
						         , Will Hanley
                           
                      
                           
                                 and Fred Gibbs
                           
                      
                
                <br/>
                
                </ul>
                
				
			</header>

            

			<div class="content">
	              <h2 id="lesson-goals">Lesson Goals</h2>

<p>This lesson explains why many cultural institutions are adopting graph
databases, and how researchers can access these data though the query language
called SPARQL.</p>

<p><em>Table of contents</em></p>

<ul>
  <li><a href="graph-databases-and-SPARQL.html#graph-databases-rdf-and-linked-open-data">Graph Databases, RDF, and Linked Open Data</a>
    <ul>
      <li><a href="graph-databases-and-SPARQL.html#rdf-in-brief">RDF in brief</a></li>
      <li><a href="graph-databases-and-SPARQL.html#searching-rdf-with-sparql">Searching RDF with SPARQL</a></li>
      <li><a href="graph-databases-and-SPARQL.html#uris-and-literals">URIs and Literals</a></li>
      <li><a href="graph-databases-and-SPARQL.html#terms-to-review">Terms to review</a></li>
    </ul>
  </li>
  <li><a href="graph-databases-and-SPARQL.html#real-world-queries">Real-world queries</a>
    <ul>
      <li><a href="graph-databases-and-SPARQL.html#all-the-statements-for-one-object">All the statements for one object</a></li>
      <li><a href="graph-databases-and-SPARQL.html#complex-queries">Complex queries</a></li>
      <li><a href="graph-databases-and-SPARQL.html#filter">FILTER</a></li>
      <li><a href="graph-databases-and-SPARQL.html#aggregation">Aggregation</a></li>
      <li><a href="graph-databases-and-SPARQL.html#linking-multiple-sparql-endpoints">Linking multiple SPARQL endpoints</a></li>
    </ul>
  </li>
  <li><a href="graph-databases-and-SPARQL.html#working-with-sparql-results">Working with SPARQL results</a>
    <ul>
      <li><a href="graph-databases-and-SPARQL.html#export-results-to-csv">Export results to CSV</a></li>
      <li><a href="graph-databases-and-SPARQL.html#export-results-to-palladio">Export results to Palladio</a></li>
    </ul>
  </li>
  <li><a href="graph-databases-and-SPARQL.html#further-reading">Further reading</a></li>
</ul>

<h1 id="graph-databases-rdf-and-linked-open-data">Graph Databases, RDF, and Linked Open Data</h1>

<p>Many cultural institutions now offer access to their collections information
through <a href="intro-to-the-zotero-api.html">web Application Programming Interfaces</a>. While these APIs are a
powerful way to access individual records in a machine-readable manner, they are
not ideal for cultural heritage data because they are structured to work for a
predetermined set of queries. For example, a museum may have information on
donors, artists, artworks, exhibitions, and provenance, but its web API may
offer only object-wise retrieval, making it difficult or impossible to search
for associated data about donors, artists, provenance, etc. This structure is
great if you come looking for information about particular objects. However, it
makes it difficult to aggregate information about every artist or donor that
happens to be described in the dataset as well.</p>

<p>RDF databases are well-suited to expressing complex relationships between many
entities, like people, places, events, and concepts tied to individual
objects. These databases are often referred to as “graph” databases because they
structure information as a graph or network, where a set of resources, or nodes,
are connected together by edges that describe the relationships between each
resource.</p>

<p>Because RDF databases support the use of URLs (weblinks), they can be made
available online and linked to other databases, hence the term “Linked Open
Data”. Major art collections including the <a href="http://collection.britishmuseum.org">British Museum</a>, <a href="http://labs.europeana.eu/api/linked-open-data-introduction">Europeana</a>,
the <a href="http://americanart.si.edu">Smithsonian American Art Museum</a>, and the <a href="http://britishart.yale.edu/collections/using-collections/technology/linked-open-data">Yale Center for
British Art</a> have published their collections data as LOD. The <a href="http://vocab.getty.edu">Getty
Vocabulary Program</a>, has also released their series of authoritative
databases on geographic place names, terms for describing art and architecture,
and variant spellings of artist names, as LOD.</p>

<p>SPARQL is the language used to query these databases. This language is
particularly powerful because it does not presuppose the perspectives that users
will bring to the data. A query about objects and a query about donors is
basically equivalent to such a database. Unfortunately, many tutorials on SPARQL
use extremely simplified data models that don’t resemble the more complex
datasets released by cultural heritage institutions. This tutorial gives a crash
course on SPARQL using a dataset that a humanist might actually find in the
wilds of the Internet. In this tutorial, we will learn how to query the British
Museum Linked Open Data collection.</p>

<h2 id="rdf-in-brief">RDF in brief</h2>

<p>RDF represents information in a series of three-part “statements” that comprise
a subject, predicate, and an object, e.g.:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;The Nightwatch&gt; &lt;was created by&gt; &lt;Rembrandt van Rijn&gt; .
</code></pre>
</div>

<p>(Note that just like any good sentence, they each have a period at the end.)</p>

<p>Here, the subject <code class="highlighter-rouge">&lt;The Nightwatch&gt;</code> and the object <code class="highlighter-rouge">&lt;Rembrandt van Rijn&gt;</code> can
be thought of as two nodes of the graph, with the predicate <code class="highlighter-rouge">&lt;was created by&gt;</code>
defining an edge between them. (Technically, <code class="highlighter-rouge">&lt;was created by&gt;</code> can, in other
queries, be treated as an object or subject itself, but that is beyond the scope
of this tutorial.)</p>

<p>A pseudo-RDF database might contain interrelated statements like these:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>...
&lt;The Nightwatch&gt; &lt;was created by&gt; &lt;Rembrandt van Rijn&gt; .
&lt;The Nightwatch&gt; &lt;was created in&gt; &lt;1642&gt; .
&lt;The Nightwatch&gt; &lt;has medium&gt; &lt;oil on canvas&gt; .
&lt;Rembrandt van Rijn&gt; &lt;was born in&gt; &lt;1606&gt; .
&lt;Rembrandt van Rijn&gt; &lt;has nationality&gt; &lt;Dutch&gt; .
&lt;Johannes Vermeer&gt; &lt;has nationality&gt; &lt;Dutch&gt; .
&lt;Woman with a Balance&gt; &lt;was created by&gt; &lt;Johannes Vermeer&gt; .
&lt;Woman with a Balance&gt; &lt;has medium&gt; &lt;oil on canvas&gt; .
...
</code></pre>
</div>

<p>If we were to visualize these statements as nodes and edges within network
graph, it would appear like so:</p>

<!--figure tags without plugin: http://stackoverflow.com/questions/19331362/using-an-image-caption-in-markdown-jekyll -->

<figure>
	<a href="../images/sparql01.svg">
		<img src="../images/sparql01.svg" alt="A network visualization of the pseudo-RDF shown above. Arrows indicate the 'direction' of the predicate. For example, that 'Woman with a Balance was created by Vermeer', and not the other way around." />
	</a>
<figcaption>
    <p>A network visualization of the pseudo-RDF shown above. Arrows indicate the ‘direction’ of the predicate. For example, that ‘Woman with a Balance was created by Vermeer’, and not the other way around.</p>

</figcaption>
</figure>

<p>A traditional relational database might split attributes about artworks and
attributes about artists into separate tables. In an RDF/graph database, all
these data points belong to the same interconnected graph, which allows users
maximum flexibility in deciding how they wish to query it.</p>

<h2 id="searching-rdf-with-sparql">Searching RDF with SPARQL</h2>

<p>SPARQL lets us translate heavily interlinked, graph data into normalized,
tabular data with rows and columns you can open in programs like Excel, or
import into a visualization suite such as <a href="http://plot.ly">plot.ly</a> or
<a href="http://palladio.designhumanities.org/">Palladio</a>.</p>

<p>It is useful to think of a SPARQL query as a <a href="https://en.wikipedia.org/wiki/Mad_Libs">Mad
Lib</a> - a set of sentences with blanks in
them. The database will take this query and find every set of matching
statements that correctly fill in those blanks, returning the matching values to
us as a table. Take this SPARQL query:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT ?painting
WHERE {
  ?painting &lt;has medium&gt; &lt;oil on canvas&gt; .
}
</code></pre>
</div>

<p><code class="highlighter-rouge">?painting</code> in this query stands in for the node (or nodes) that the database
will return. On receiving this query, the database will search for all values of
<code class="highlighter-rouge">?painting</code> that properly complete the RDF statement <code class="highlighter-rouge">&lt;has medium&gt; &lt;oil on
canvas&gt; .</code>:</p>

<!--figure tags without plugin: http://stackoverflow.com/questions/19331362/using-an-image-caption-in-markdown-jekyll -->

<figure>
	<a href="../images/sparql01-1.svg">
		<img src="../images/sparql01-1.svg" alt="A visualization of what our query is looking for." />
	</a>
<figcaption>
    <p>A visualization of what our query is looking for.</p>

</figcaption>
</figure>

<p>When the query runs against the full database, it looks for the subjects,
predicates, and objects that match this statement, while excluding the rest of
the data:</p>

<!--figure tags without plugin: http://stackoverflow.com/questions/19331362/using-an-image-caption-in-markdown-jekyll -->

<figure>
	<a href="../images/sparql02.svg">
		<img src="../images/sparql02.svg" alt="A visualization of the SPARQL query, with mentioned elements in orange, and selected elements (those that will be returned in the results) in red." />
	</a>
<figcaption>
    <p>A visualization of the SPARQL query, with mentioned elements in orange, and selected elements (those that will be returned in the results) in red.</p>

</figcaption>
</figure>

<p>And our results might look like this table:</p>

<table>
  <thead>
    <tr>
      <th>painting</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>The Nightwatch</td>
    </tr>
    <tr>
      <td>Woman with a Balance</td>
    </tr>
  </tbody>
</table>

<p>What makes RDF and SPARQL powerful is the ability to create complex queries that
reference many variables at a time. For example, we could search our pseudo-RDF
database for  paintings by any artist who is Dutch:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT ?artist ?painting
WHERE {
  ?artist &lt;has nationality&gt; &lt;Dutch&gt; .
  ?painting &lt;was created by&gt; ?artist .
}
</code></pre>
</div>

<p>Here we’ve introduced a second variable, <code class="highlighter-rouge">?artist</code>. The RDF database will return
all matching combinations of <code class="highlighter-rouge">?artist</code> and <code class="highlighter-rouge">?painting</code> that fulfill both of
these statements.</p>

<!--figure tags without plugin: http://stackoverflow.com/questions/19331362/using-an-image-caption-in-markdown-jekyll -->

<figure>
	<a href="../images/sparql02-1.svg">
		<img src="../images/sparql02-1.svg" alt="A visualization of the SPARQL query, with mentioned elements in orange, and selected elements (those that will be returned in the results) in red." />
	</a>
<figcaption>
    <p>A visualization of the SPARQL query, with mentioned elements in orange, and selected elements (those that will be returned in the results) in red.</p>

</figcaption>
</figure>

<table>
  <thead>
    <tr>
      <th>artist</th>
      <th>painting</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Rembrandt van Rijn</td>
      <td>The Nightwatch</td>
    </tr>
    <tr>
      <td>Johannes Vermeer</td>
      <td>Woman with a Balance</td>
    </tr>
  </tbody>
</table>

<h2 id="uris-and-literals">URIs and Literals</h2>

<p>So far, we have been looking at a toy representation of RDF that uses
easy-to-read text. However, RDF is primarily stored as URIs (Uniform Resource
Identifiers) that separate conceptual entities from their plain-English (or
other language!) labels. (Note that a URL, or Uniform Resource Locator, is a URI
for a resource that is accessible on the web) In real RDF, our original
statement:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;The Nightwatch&gt;   &lt;was created by&gt;   &lt;Rembrandt van Rijn&gt; .
</code></pre>
</div>

<p>would more likely look something like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;http://data.rijksmuseum.nl/item/8909812347&gt; &lt;http://purl.org/dc/terms/creator&gt;  &lt;http://dbpedia.org/resource/Rembrandt&gt;.
</code></pre>
</div>

<p><em>N.B. the Rijksmuseum has not (yet) built their own Linked Data site, so the URI in this query is just for demo purposes.</em></p>

<p>In order to get the human-readable version of the information represented by
each of these URIs, what we’re really doing is just retrieving more RDF
statements. Even the predicate in that statement has its own literal label:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;http://data.rijksmuseum.nl/item/8909812347&gt; &lt;http://purl.org/dc/terms/title&gt; "The Nightwatch" .

&lt;http://purl.org/dc/terms/creator&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#label&gt; "was created by" .

&lt;http://dbpedia.org/resource/Rembrandt&gt; &lt;http://xmlns.com/foaf/0.1/name&gt; "Rembrandt van Rijn" .
</code></pre>
</div>

<p>You will notice that, unlike the URIs in the query that are surrounded by <code class="highlighter-rouge">&lt;&gt;</code>,
the <em>objects</em> of these statements are just strings of text within quotation
marks, known as <em>literals</em>. Literals are unlike URIs in that they represent
values, rather than references. For example,
<code class="highlighter-rouge">&lt;http://dbpedia.org/resource/Rembrandt&gt;</code> represents an entity that may
reference (and be referenced by) any number of other statements (say, birth
dates, students, or family members), while the text string <code class="highlighter-rouge">"Rembrandt van
Rijn"</code> stands only for itself. Literals do not point to other nodes in the
graph, and they can only ever be objects in an RDF statement. Other literal
values in RDF include dates and numbers.</p>

<p>See the <em>predicates</em> in these statements, with domain names like <code class="highlighter-rouge">purl.org</code>,
<code class="highlighter-rouge">w3.org</code>, and <code class="highlighter-rouge">xmlns.com</code>? These are some of the many providers of ontologies
that help standardize the way we describe relationships between bits of
information like “title”, “label”, “creator”, or “name”. The more RDF/LOD that
you work with, the more of these providers you’ll find.</p>

<p>URIs can become unwieldy when composing SPARQL queries, which is why we’ll
use <em>prefixes</em>. These are shortcuts that allow us to skip typing out entire long
URIs. For example, remember that predicate for retrieving the title of the
<em>Nightwatch</em>, <code class="highlighter-rouge">&lt;http://purl.org/dc/terms/title&gt;</code>? With these prefixes, we just
need to type <code class="highlighter-rouge">dct:title</code> whenever we need to use a <code class="highlighter-rouge">purl.org</code> predicate. <code class="highlighter-rouge">dct:</code>
stands in for <code class="highlighter-rouge">http://purl.org/dc/terms/</code>, and <code class="highlighter-rouge">title</code> just gets pasted onto the
end of this link.</p>

<p>For example, with the prefix <code class="highlighter-rouge">PREFIX rkm: &lt;http://data.rijksmuseum.nl/&gt;</code>,
appended to the start of our SPARQL query,
<code class="highlighter-rouge">&lt;http://data.rijksmuseum.nl/item/8909812347&gt;</code> becomes <code class="highlighter-rouge">rkm:item/8909812347</code>
instead.</p>

<p>Many live databases, such as the British Museum database that we will try our
first new queries on, already define these prefixes for us, so we won’t have to
explicitly state them in our queries. However, you should now be able to
recognize whenever we use one in a SPARQL query. Also be aware that, prefixes
can be arbitrarily assigned with whatever abbreviations you like, different
endpoints may use slightly different prefixes for the same namespace (e.g. <code class="highlighter-rouge">dct</code>
vs. <code class="highlighter-rouge">dcterms</code> for <code class="highlighter-rouge">&lt;http://purl.org/dc/terms/&gt;</code>).</p>

<h2 id="terms-to-review">Terms to review</h2>

<ul>
  <li><strong>SPARQL</strong> - <em>Protocol and RDF Query Language</em> - The language used to query RDF graph databases</li>
  <li><strong>RDF</strong> - <em>Resource Description Framework</em> - A method for structuring data as a graph or network of connected statements, rather than a series of tables.</li>
  <li><strong>LOD</strong> - <em>Linked Open Data</em> - LOD is RDF data published online with dedicated URIs in such a manner than developers can reliably reference it.</li>
  <li><strong>statement</strong> - Sometimes also called a “triple”, an RDF statement is a quantum of knowledge comprising a <em>subject</em>, <em>predicate</em>, and <em>object</em>.</li>
  <li><strong>URI</strong> - <em>Uniform Resource Identifier</em> - a string of characters for identifying a resource. RDF statements use URIs to link various resources together. A URL, or uniform resource locator, is a type of URI that points to resources on the web.</li>
  <li><strong>literal</strong> - Some objects in RDF statements do not refer to other resources with a URI, but instead convey a value, such as text (<code class="highlighter-rouge">"Rembrandt van Rijn"</code>), a number (<code class="highlighter-rouge">5</code>), or a date (<code class="highlighter-rouge">1606-06-15</code>). These are known as literals.</li>
  <li><strong>prefix</strong> - In order to simplify SPARQL queries, a user may specify prefixes that act as abbreviations for full URIs. These abbreviations, or <strong>QNames</strong>, are also used in namespaced XML documents.</li>
</ul>

<h1 id="real-world-queries">Real-world queries</h1>

<h2 id="all-the-statements-for-one-object">All the statements for one object</h2>

<p>Let’s start our first query using the <a href="http://collection.britishmuseum.org/sparql">British Museum SPARQL endpoint</a>. A
SPARQL endpoint is a web address that accepts SPARQL queries and returns
results. The BM endpoint is like many others: if you navigate to it in a web
browser, it presents you with a text box for composing queries.</p>

<!--figure tags without plugin: http://stackoverflow.com/questions/19331362/using-an-image-caption-in-markdown-jekyll -->

<figure>
	<a href="../images/sparql03.png">
		<img src="../images/sparql03.png" alt="The BM SPARQL endpoint webpage. For all the queries in this tutorial, make sure that you have left the 'Include inferred' and 'Expand results over equivalent URIs' boxes unchecked." />
	</a>
<figcaption>
    <p>The BM SPARQL endpoint webpage. For all the queries in this tutorial, make sure that you have left the ‘Include inferred’ and ‘Expand results over equivalent URIs’ boxes unchecked.</p>

</figcaption>
</figure>

<p>When starting to explore a new RDF database, it helps to look at the
relationships that stem from a single <a href="http://collection.britishmuseum.org/id/object/PPA82633">example
object</a>.</p>

<p>(For each of the following queries, click on the “Run query” link below to see
the results. Click on the “Edit query” link to go to a page with the query
automatically pasted the query into the BM’s endpoint. You can then run it as
is, or modify it before requesting the results. Remember when editing the query
before running to uncheck the ‘Include inferred’ box.)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT ?p ?o
WHERE {
  &lt;http://collection.britishmuseum.org/id/object/PPA82633&gt; ?p ?o .
}
</code></pre>
</div>

<p><a href="http://collection.britishmuseum.org/sparql?query=SELECT+*%0D%0AWHERE+%7B%0D%0A++%3Chttp%3A%2F%2Fcollection.britishmuseum.org%2Fid%2Fobject%2FPPA82633%3E+%3Fp+%3Fo+.%0D%0A++%7D&amp;_implicit=false&amp;_equivalent=false&amp;_form=%2Fsparql">Run query</a> /
<a href="http://collection.britishmuseum.org/sparql?sample=SELECT+*%0D%0AWHERE+%7B%0D%0A++%3Chttp%3A%2F%2Fcollection.britishmuseum.org%2Fid%2Fobject%2FPPA82633%3E+%3Fp+%3Fo+.%0D%0A++%7D">Edit query</a></p>

<p>By calling <code class="highlighter-rouge">SELECT ?p ?o</code> we’re asking the database to return the values of <code class="highlighter-rouge">?p</code>
and <code class="highlighter-rouge">?o</code> as described in the <code class="highlighter-rouge">WHERE {}</code> command. This query returns every
statement for which our example artwork,
<code class="highlighter-rouge">&lt;http://collection.britishmuseum.org/id/object/PPA82633&gt;</code>, is the subject. <code class="highlighter-rouge">?p</code>
is in the middle position of the RDF statement in the <code class="highlighter-rouge">WHERE {}</code> command, so it
returns any predicates matching this statement, while <code class="highlighter-rouge">?o</code> in the final position
returns all objects. Though I have named them <code class="highlighter-rouge">?p</code> and <code class="highlighter-rouge">?o</code> here, as you will
see below we can name these variables anything we like. Indeed, it will be
useful to give them meaningful names for the complex queries that follow!.</p>

<!--figure tags without plugin: http://stackoverflow.com/questions/19331362/using-an-image-caption-in-markdown-jekyll -->

<figure>
	<a href="../images/sparql04.png">
		<img src="../images/sparql04.png" alt="An initial list of all the predicates and objects associated with one artwork in the British Museum." />
	</a>
<figcaption>
    <p>An initial list of all the predicates and objects associated with one artwork in the British Museum.</p>

</figcaption>
</figure>

<p>The BM endpoint formats the results table with hyperlinks for every variable
that is itself an RDF node, so by clicking on any one of these links you can
shift to seeing all the predicates and objects for that newly-selected node.
Note that BM automatically includes a wide range of SPARQL prefixes in its
queries, so you will find many hyperlinks are displayed in their abbreviated
versions; if you mouse over them your browser will display their unabbreviated
URIs.</p>

<!--figure tags without plugin: http://stackoverflow.com/questions/19331362/using-an-image-caption-in-markdown-jekyll -->

<figure>
	<a href="../images/sparql04-1.svg">
		<img src="../images/sparql04-1.svg" alt="Visualizing a handful of the nodes returned by the first query to the BM. Elements in this graph that are also in the table of results above are colored red. Additional levels in the hierarchy are included as a preview of how this single print connects to the larger BM graph." />
	</a>
<figcaption>
    <p>Visualizing a handful of the nodes returned by the first query to the BM. Elements in this graph that are also in the table of results above are colored red. Additional levels in the hierarchy are included as a preview of how this single print connects to the larger BM graph.</p>

</figcaption>
</figure>

<p>Let’s find out how they store the object type information: look for the
predicate <code class="highlighter-rouge">&lt;bmo:PX_object_type&gt;</code> (highlighted in the figure above) and click on
the link for <code class="highlighter-rouge">thes:x8577</code> to navigate to the node describing the particular
object type “print”:</p>

<!--figure tags without plugin: http://stackoverflow.com/questions/19331362/using-an-image-caption-in-markdown-jekyll -->

<figure>
	<a href="../images/sparql05.png">
		<img src="../images/sparql05.png" alt="The resource page for `thes:x8577` ('print') in the British Museum LOD." />
	</a>
<figcaption>
    <p>The resource page for <code class="highlighter-rouge">thes:x8577</code> (‘print’) in the British Museum LOD.</p>

</figcaption>
</figure>

<p>You’ll note how this node has an plain-text label, as well as ties to related
artwork type nodes within the database.</p>

<h2 id="complex-queries">Complex queries</h2>

<p>To find other objects of the same type with the preferred label “print”, we can
call this query:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT ?object
WHERE {

  # Search for all values of ?object that have a given "object type"
  ?object bmo:PX_object_type ?object_type .

  # That object type should have the label "print"
  ?object_type skos:prefLabel "print" .
}
</code></pre>
</div>

<p><a href="http://collection.britishmuseum.org/sparql?query=SELECT+%3Fobject%0D%0AWHERE+%7B%0D%0A++%3Fobject+bmo%3APX_object_type+%3Fobject_type+.%0D%0A++%3Fobject_type+skos%3AprefLabel+%22print%22+.%0D%0A%7D&amp;_implicit=false&amp;implicit=false&amp;_equivalent=false&amp;_form=%2Fsparql">Run query</a> / <a href="http://collection.britishmuseum.org/sparql?sample=PREFIX+bmo%3A+%3Chttp%3A%2F%2Fcollection.britishmuseum.org%2Fid%2Fontology%2F%3E%0APREFIX+skos%3A+%3Chttp%3A%2F%2Fwww.w3.org%2F2004%2F02%2Fskos%2Fcore%23%3E%0ASELECT+%3Fobject%0D%0AWHERE+%7B%0D%0A++%3Fobject+bmo%3APX_object_type+%3Fobject_type+.%0D%0A++%3Fobject_type+skos%3AprefLabel+%22print%22+.%0D%0A%7D">Edit query</a> / <a href="https://hypothes.is/a/AVLH7aAMvTW_3w8Ly19w">See a user-generated query</a></p>

<!--figure tags without plugin: http://stackoverflow.com/questions/19331362/using-an-image-caption-in-markdown-jekyll -->

<figure>
	<a href="../images/sparql06.png">
		<img src="../images/sparql06.png" alt="A one-column table returned by our query for every object with type 'print'" />
	</a>
<figcaption>
    <p>A one-column table returned by our query for every object with type ‘print’</p>

</figcaption>
</figure>

<p>Remember that, because <code class="highlighter-rouge">"print"</code> here is a <em>literal</em>, we enclose it within
quotation marks in our query. When you include literals in a SPARQL query, the
database will only return <em>exact</em> matches for those values.</p>

<p>Note that, because <code class="highlighter-rouge">?object_type</code> is not present in the <code class="highlighter-rouge">SELECT</code> command, it
will not show up in the results table. However, it is essential to structuring
our query, because it connects the dots from <code class="highlighter-rouge">?object</code> to the label <code class="highlighter-rouge">"print"</code>.</p>

<h2 id="filter">FILTER</h2>

<p>In the previous query, our SPARQL query searched for an exact match for the
object type with the text label “print”. However, often we want to match literal
values that fall within a certain range, such as dates. For this, we’ll use the
<code class="highlighter-rouge">FILTER</code> command.</p>

<p>To find URIs for all the prints in the BM created between 1580 and 1600, we’ll
need to first figure out where the database stores dates in relationship to the
object node, and then add references to those dates in our query. Similar to the
way that we followed a single link to determine an object type, we must hop
through several nodes to find the production dates associated with a given
object:</p>

<!--figure tags without plugin: http://stackoverflow.com/questions/19331362/using-an-image-caption-in-markdown-jekyll -->

<figure>
	<a href="../images/sparql07.svg">
		<img src="../images/sparql07.svg" alt="Visualizing part of the British Museum's data model where production dates are connected to objects." />
	</a>
<figcaption>
    <p>Visualizing part of the British Museum’s data model where production dates are connected to objects.</p>

</figcaption>
</figure>

<div class="highlighter-rouge"><pre class="highlight"><code># Return object links and creation date
SELECT ?object ?date
WHERE {

  # We'll use our previous command to search only for
  # objects of type "print"
  ?object bmo:PX_object_type ?object_type .
  ?object_type skos:prefLabel "print" .

  # We need to link though several nodes to find the
  # creation date associated with an object
  ?object ecrm:P108i_was_produced_by ?production .
  ?production ecrm:P9_consists_of ?date_node .
  ?date_node ecrm:P4_has_time-span ?timespan .
  ?timespan ecrm:P82a_begin_of_the_begin ?date .

  # As you can see, we need to connect quite a few dots
  # to get to the date node! Now that we have it, we can
  # filter our results. Because we are filtering by date,
  # we must attach the tag ^^xsd:date after our date strings.
  # This tag tells the database to interpret the string
  # "1580-01-01" as the date 1 January 1580.

  FILTER(?date &gt;= "1580-01-01"^^xsd:date &amp;&amp;
         ?date &lt;= "1600-01-01"^^xsd:date)
}
</code></pre>
</div>

<p><a href="http://collection.britishmuseum.org/sparql?query=%23+Return+object+links+and+creation+date%0D%0ASELECT+%3Fobject+%3Fdate%0D%0AWHERE+%7B%0D%0A%0D%0A++%23+We%27ll+use+our+previous+command+to+search+only+for+objects+of+type+%22print%22%0D%0A++%3Fobject+bmo%3APX_object_type+%3Fobject_type+.%0D%0A++%3Fobject_type+skos%3AprefLabel+%22print%22+.%0D%0A%0D%0A++%23+We+need+to+link+though+several+nodes+to+find+the+creation+date+associated%0D%0A++%23+with+an+object%0D%0A++%3Fobject+ecrm%3AP108i_was_produced_by+%3Fproduction+.%0D%0A++%3Fproduction+ecrm%3AP9_consists_of+%3Fdate_node+.%0D%0A++%3Fdate_node+ecrm%3AP4_has_time-span+%3Ftimespan+.%0D%0A++%3Ftimespan+ecrm%3AP82a_begin_of_the_begin+%3Fdate+.%0D%0A%0D%0A++%23+Yes%2C+we+need+to+connect+quite+a+few+dots+to+get+to+the+date+node%21+Now+that%0D%0A++%23+we+have+it%2C+we+can+filter+our+results.+Because+we+are+filtering+a+date%2C+we%0D%0A++%23+must+attach+the+xsd%3Adate+tag+to+our+date+strings+so+that+SPARQL+knows+how+to%0D%0A++%23+parse+them.%0D%0A%0D%0A++FILTER%28%3Fdate+%3E%3D+%221580-01-01%22%5E%5Exsd%3Adate+%26%26+%3Fdate+%3C%3D+%221600-01-01%22%5E%5Exsd%3Adate%29%0D%0A%7D&amp;_implicit=false&amp;_equivalent=false&amp;_form=%2Fsparql">Run query</a> / <a href="http://collection.britishmuseum.org/sparql?sample=%23+Return+object+links+and+creation+date%0D%0APREFIX+bmo%3A+%3Chttp%3A%2F%2Fcollection.britishmuseum.org%2Fid%2Fontology%2F%3E%0APREFIX+skos%3A+%3Chttp%3A%2F%2Fwww.w3.org%2F2004%2F02%2Fskos%2Fcore%23%3E%0APREFIX+ecrm%3A+%3Chttp%3A%2F%2Ferlangen-crm.org%2Fcurrent%2F%3E%0APREFIX+xsd%3A+%3Chttp%3A%2F%2Fwww.w3.org%2F2001%2FXMLSchema%23%3E%0ASELECT+%3Fobject+%3Fdate%0D%0AWHERE+%7B%0D%0A%0D%0A++%23+We%27ll+use+our+previous+command+to+search+only+for+objects+of+type+%22print%22%0D%0A++%3Fobject+bmo%3APX_object_type+%3Fobject_type+.%0D%0A++%3Fobject_type+skos%3AprefLabel+%22print%22+.%0D%0A%0D%0A++%23+We+need+to+link+though+several+nodes+to+find+the+creation+date+associated%0D%0A++%23+with+an+object%0D%0A++%3Fobject+ecrm%3AP108i_was_produced_by+%3Fproduction+.%0D%0A++%3Fproduction+ecrm%3AP9_consists_of+%3Fdate_node+.%0D%0A++%3Fdate_node+ecrm%3AP4_has_time-span+%3Ftimespan+.%0D%0A++%3Ftimespan+ecrm%3AP82a_begin_of_the_begin+%3Fdate+.%0D%0A%0D%0A++%23+Yes%2C+we+need+to+connect+quite+a+few+dots+to+get+to+the+date+node%21+Now+that%0D%0A++%23+we+have+it%2C+we+can+filter+our+results.+Because+we+are+filtering+a+date%2C+we%0D%0A++%23+must+attach+the+xsd%3Adate+tag+to+our+date+strings+so+that+SPARQL+knows+how+to%0D%0A++%23+parse+them.%0D%0A%0D%0A++FILTER%28%3Fdate+%3E%3D+%221580-01-01%22%5E%5Exsd%3Adate+%26%26+%3Fdate+%3C%3D+%221600-01-01%22%5E%5Exsd%3Adate%29%0D%0A%7D">Edit query</a></p>

<!--figure tags without plugin: http://stackoverflow.com/questions/19331362/using-an-image-caption-in-markdown-jekyll -->

<figure>
	<a href="../images/sparql08.png">
		<img src="../images/sparql08.png" alt="All BM prints made between 1580 and 1600" />
	</a>
<figcaption>
    <p>All BM prints made between 1580 and 1600</p>

</figcaption>
</figure>

<h2 id="aggregation">Aggregation</h2>

<p>So far we have only used the <code class="highlighter-rouge">SELECT</code> command to return a table of objects.
However, SPARQL allows us to do more advanced analysis such as grouping,
counting, and sorting.</p>

<p>Say we would like to keep looking at objects made between 1580 and 1600, but we
want to understand how many objects of each type the BM has in its collections.
Instead of limiting our results to objects of type “print”, we will instead use
<code class="highlighter-rouge">COUNT</code> to tally our search results by type.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT ?type (COUNT(?type) as ?n)
WHERE {
  # We still need to indicate the ?object_type variable,
  # however we will not require it to match "print" this time

  ?object bmo:PX_object_type ?object_type .
  ?object_type skos:prefLabel ?type .

  # Once again, we will also filter by date
  ?object ecrm:P108i_was_produced_by ?production .
  ?production ecrm:P9_consists_of ?date_node .
  ?date_node ecrm:P4_has_time-span ?timespan .
  ?timespan ecrm:P82a_begin_of_the_begin ?date .
  FILTER(?date &gt;= "1580-01-01"^^xsd:date &amp;&amp;
         ?date &lt;= "1600-01-01"^^xsd:date)
}
# The GROUP BY command designates the variable to tally by,
# and the ORDER BY DESC() command sorts the results by
# descending number.
GROUP BY ?type
ORDER BY DESC(?n)
</code></pre>
</div>

<p><a href="http://collection.britishmuseum.org/sparql?query=SELECT+%3Ftype+%28COUNT%28%3Ftype%29+as+%3Fn%29%0D%0AWHERE+%7B%0D%0A++%23+We+still+need+to+indicate+the+%3Fobject_type+variable%2C+however+we+will+not%0D%0A++%23+require+it+to+match+%22print%22+this+time%0D%0A%0D%0A++%3Fobject+bmo%3APX_object_type+%3Fobject_type+.%0D%0A++%3Fobject_type+skos%3AprefLabel+%3Ftype+.%0D%0A%0D%0A++%23+Once+again%2C+we+will+also+filter+by+date%0D%0A++%3Fobject+ecrm%3AP108i_was_produced_by+%3Fproduction+.%0D%0A++%3Fproduction+ecrm%3AP9_consists_of+%3Fdate_node+.%0D%0A++%3Fdate_node+ecrm%3AP4_has_time-span+%3Ftimespan+.%0D%0A++%3Ftimespan+ecrm%3AP82a_begin_of_the_begin+%3Fdate+.%0D%0A++FILTER%28%3Fdate+%3E%3D+%221580-01-01%22%5E%5Exsd%3Adate+%26%26+%3Fdate+%3C%3D+%221600-01-01%22%5E%5Exsd%3Adate%29%0D%0A%7D%0D%0A%23+The+GROUP+BY+command+designates+the+variable+to+tally+by%2C+and+the+ORDER+BY%0D%0A%23+DESC%28%29+command+sorts+the+results+by+descending+number.%0D%0AGROUP+BY+%3Ftype%0D%0AORDER+BY+DESC%28%3Fn%29&amp;_implicit=false&amp;_equivalent=false&amp;_form=%2Fsparql">Run query</a> / <a href="http://collection.britishmuseum.org/sparql?sample=PREFIX+bmo%3A+%3Chttp%3A%2F%2Fcollection.britishmuseum.org%2Fid%2Fontology%2F%3E%0APREFIX+skos%3A+%3Chttp%3A%2F%2Fwww.w3.org%2F2004%2F02%2Fskos%2Fcore%23%3E%0APREFIX+ecrm%3A+%3Chttp%3A%2F%2Ferlangen-crm.org%2Fcurrent%2F%3E%0APREFIX+xsd%3A+%3Chttp%3A%2F%2Fwww.w3.org%2F2001%2FXMLSchema%23%3E%0ASELECT+%3Ftype+%28COUNT%28%3Ftype%29+as+%3Fn%29%0D%0AWHERE+%7B%0D%0A++%23+We+still+need+to+indicate+the+%3Fobject_type+variable%2C+however+we+will+not%0D%0A++%23+require+it+to+match+%22print%22+this+time%0D%0A%0D%0A++%3Fobject+bmo%3APX_object_type+%3Fobject_type+.%0D%0A++%3Fobject_type+skos%3AprefLabel+%3Ftype+.%0D%0A%0D%0A++%23+Once+again%2C+we+will+also+filter+by+date%0D%0A++%3Fobject+ecrm%3AP108i_was_produced_by+%3Fproduction+.%0D%0A++%3Fproduction+ecrm%3AP9_consists_of+%3Fdate_node+.%0D%0A++%3Fdate_node+ecrm%3AP4_has_time-span+%3Ftimespan+.%0D%0A++%3Ftimespan+ecrm%3AP82a_begin_of_the_begin+%3Fdate+.%0D%0A++FILTER%28%3Fdate+%3E%3D+%221580-01-01%22%5E%5Exsd%3Adate+%26%26+%3Fdate+%3C%3D+%221600-01-01%22%5E%5Exsd%3Adate%29%0D%0A%7D%0D%0A%23+The+GROUP+BY+command+designates+the+variable+to+tally+by%2C+and+the+ORDER+BY%0D%0A%23+DESC%28%29+command+sorts+the+results+by+descending+number.%0D%0AGROUP+BY+%3Ftype%0D%0AORDER+BY+DESC%28%3Fn%29">Edit query</a></p>

<!--figure tags without plugin: http://stackoverflow.com/questions/19331362/using-an-image-caption-in-markdown-jekyll -->

<figure>
	<a href="../images/sparql09.png">
		<img src="../images/sparql09.png" alt="Counts of objects by type produced between 1580 and 1600." />
	</a>
<figcaption>
    <p>Counts of objects by type produced between 1580 and 1600.</p>

</figcaption>
</figure>

<h2 id="linking-multiple-sparql-endpoints">Linking multiple SPARQL endpoints</h2>

<p>Up until now, we have constructed queries that look for patterns in one dataset
alone. In the ideal world envisioned by Linked Open Data advocates, multiple
databases can be interlinked to allow very complex queries dependent on
knowledge present in different locations. However, this is easier said than
done, and many endpoints (the BM’s included) do not yet reference outside
authorities.</p>

<p>One endpoint that does, however, is
<a href="http://europeana.ontotext.com/sparql">Europeana’s</a>. They have created links
between the objects in their database and records about individuals in
<a href="http://wiki.dbpedia.org/">DBPedia</a> and <a href="https://viaf.org/">VIAF</a>, places in
<a href="http://sws.geonames.org/">GeoNames</a>, and concepts in the Getty Art &amp;
Architecture thesaurus. SPARQL allows you to insert <code class="highlighter-rouge">SERVICE</code> statements that
instruct the database to “phone a friend” and run a portion of the query on
an outside dataset, using the results to complete the query on the local
dataset. While this lesson will go into the data models in Europeana and DBpedia in depth, the following query illustrates how a <code class="highlighter-rouge">SELECT</code> statement works. You may run it yourself by copying and pasting the query text into the <a href="http://europeana.ontotext.com/sparql">Europeana endpoint</a>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>PREFIX edm:    &lt;http://www.europeana.eu/schemas/edm/&gt;
PREFIX rdf:    &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
PREFIX dbo:    &lt;http://dbpedia.org/ontology/&gt;
PREFIX dbr:    &lt;http://dbpedia.org/resource/&gt;
PREFIX rdaGr2: &lt;http://rdvocab.info/ElementsGr2/&gt;

# Find all ?object related by some ?property to an ?agent born in a
# ?dutch_city
SELECT ?object ?property ?agent ?dutch_city
WHERE {
    ?proxy ?property ?agent .
    ?proxy ore:proxyFor ?object .

    ?agent rdf:type edm:Agent .
    ?agent rdaGr2:placeOfBirth ?dutch_city .

    # ?dutch_city is defined by having "Netherlands" as its broader
    # country in DBpedia. The SERVICE statement asks
    # http://dbpdeia.org/sparql which cities have the country
    # "Netherlands". The answers to that sub-query will then be
    # used to finish off our original query about objects in the
    # Europeana database

    SERVICE &lt;http://dbpedia.org/sparql&gt; {
        ?dutch_city dbo:country dbr:Netherlands .
   }
}
# This query can potentially return a lot of objects, so let's
# just request the first 100 in order to speed up the search
LIMIT 100
</code></pre>
</div>

<!--figure tags without plugin: http://stackoverflow.com/questions/19331362/using-an-image-caption-in-markdown-jekyll -->

<figure>
	<a href="../images/sparql09-1.png">
		<img src="../images/sparql09-1.png" alt="Visualizing the query sequence of the above SPARQL request" />
	</a>
<figcaption>
    <p>Visualizing the query sequence of the above SPARQL request</p>

</figcaption>
</figure>

<p>An interlinked query like this means that we can ask Europeana questions about
its objects that rely on information about geography (what cities are in the
Netherlands?) that Europeana does not need to store and maintain itself. In the
future, more cultural LOD will hopefully link to authority databases like the
Getty’s Union List of Artist Names, allowing, for example, the British Museum to
outsource biographical data to the more complete resources at the Getty.</p>

<h1 id="working-with-sparql-results">Working with SPARQL results</h1>

<p>Having constructed and run a query… what do we do with the results? Many
endpoints offer, like the British Museum, a web-based browser that returns
human-readable results. However, SPARQL endpoints are designed to return
structured data to be used by other programs.</p>

<h2 id="export-results-to-csv">Export results to CSV</h2>

<p>In the top right corner of the results page for the BM endpoint, you will find
links for both JSON and XML downloads.  Other endpoints may also offer the
option for a CSV/TSV download, however this option is not always available. The
JSON and XML output from a SPARQL endpoint contain not only the values returned
from the <code class="highlighter-rouge">SELECT</code> statement, but also additional metadata about variable types
and languages.</p>

<p>Parsing the XML verson of this output may be done with a tool like Beautiful
Soup (<a href="intro-to-beautiful-soup.html">see its <em>Programming Historian</em>
lesson</a>) or <a href="http://openrefine.org/">Open
Refine</a>. To quickly convert JSON results from a SPARQL
endpoint into a tabular format, I recommend the free command line utility
<a href="http://stedolan.github.io/jq/download/">jq</a>. (For a tutorial on using command
line programs, see <a href="intro-to-bash.html">“Introduction to the Bash Command
Line”</a>.) The following query will convert the
special JSON RDF format into a CSV file, which you may load into your preferred
program for further analysis and visualization:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>jq -r <span class="s1">'.head.vars as $fields | ($fields | @csv), (.results.bindings[] | [.[$fields[]].value] | @csv)'</span> sparql.json &gt; sparql.csv
</code></pre>
</div>

<h2 id="export-results-to-palladio">Export results to Palladio</h2>

<p>The popular data exploration platform <a href="http://palladio.designhumanities.org/">Palladio</a> can directly load data from a
SPARQL endpoint. On the “Create a new project” screen, a link at the bottom to
“Load data from a SPARQL endpoint (beta)” will provide you a field to enter the
endpoint address, and a box for the query itself. Depending on the endpoint, you
may need to specify the file output type in the endpoint address; for example,
to load data from the BM endpoint you must use the address
<code class="highlighter-rouge">http://collection.britishmuseum.org/sparql.json</code>. Try pasting in the
aggregation query we used above to count artworks by type and clicking on “Run
query”. Palladio should display a preview table.</p>

<!--figure tags without plugin: http://stackoverflow.com/questions/19331362/using-an-image-caption-in-markdown-jekyll -->

<figure>
	<a href="../images/sparql10.png">
		<img src="../images/sparql10.png" alt="Palladio's SPARQL query interface." />
	</a>
<figcaption>
    <p>Palladio’s SPARQL query interface.</p>

</figcaption>
</figure>

<p>After previewing the data returned by the endpoint, click on the “Load data”
button at the bottom of the screen to begin manipulating it. (See this
<a href="creating-network-diagrams-from-historical-sources.html#visualize-network-data-in-palladio"><em>Programming Historian</em>
lesson</a>
for a more in-depth tutorial on Palladio.) For example, we might make a <a href="http://collection.britishmuseum.org/sparql?sample=%23+Return+object+links+and+creation+date%0D%0APREFIX+bmo%3A+%3Chttp%3A%2F%2Fcollection.britishmuseum.org%2Fid%2Fontology%2F%3E%0D%0APREFIX+skos%3A+%3Chttp%3A%2F%2Fwww.w3.org%2F2004%2F02%2Fskos%2Fcore%23%3E%0D%0APREFIX+ecrm%3A+%3Chttp%3A%2F%2Ferlangen-crm.org%2Fcurrent%2F%3E%0D%0APREFIX+xsd%3A+%3Chttp%3A%2F%2Fwww.w3.org%2F2001%2FXMLSchema%23%3E%0D%0ASELECT+DISTINCT+%3Fobject+%3Fdate+%3Fimage%0D%0AWHERE+%7B%0D%0A%0D%0A++%23+We%27ll+use+our+previous+command+to+search+only+for+objects+of+type+%22print%22%0D%0A++%3Fobject+bmo%3APX_object_type+%3Fobject_type+.%0D%0A++%3Fobject_type+skos%3AprefLabel+%22print%22+.%0D%0A%0D%0A++%23+We+need+to+link+though+several+nodes+to+find+the+creation+date+associated%0D%0A++%23+with+an+object%0D%0A++%3Fobject+ecrm%3AP108i_was_produced_by+%3Fproduction+.%0D%0A++%3Fproduction+ecrm%3AP9_consists_of+%3Fdate_node+.%0D%0A++%3Fdate_node+ecrm%3AP4_has_time-span+%3Ftimespan+.%0D%0A++%3Ftimespan+ecrm%3AP82a_begin_of_the_begin+%3Fdate+.%0D%0A%0D%0A++%23+Yes%2C+we+need+to+connect+quite+a+few+dots+to+get+to+the+date+node%21+Now+that%0D%0A++%23+we+have+it%2C+we+can+filter+our+results.+Because+we+are+filtering+a+date%2C+we%0D%0A++%23+must+attach+the+xsd%3Adate+tag+to+our+date+strings+so+that+SPARQL+knows+how+to%0D%0A++%23+parse+them.%0D%0A%0D%0A++FILTER%28%3Fdate+%3E%3D+%221580-01-01%22%5E%5Exsd%3Adate+%26%26+%3Fdate+%3C%3D+%221600-01-01%22%5E%5Exsd%3Adate%29%0D%0A++%0D%0A++%3Fobject+bmo%3APX_has_main_representation+%3Fimage+.%0D%0A%7D%0D%0ALIMIT+100">query
that returns links to the images of prints made between 1580 and
1600</a>,
and render that data as a grid of images sorted by date:</p>

<!--figure tags without plugin: http://stackoverflow.com/questions/19331362/using-an-image-caption-in-markdown-jekyll -->

<figure>
	<a href="../images/sparql11.png">
		<img src="../images/sparql11.png" alt="A gallery of images with a timeline of their creation dates generated using Palladio." />
	</a>
<figcaption>
    <p>A gallery of images with a timeline of their creation dates generated using Palladio.</p>

</figcaption>
</figure>

<p>Note that Palladio is designed to work with relatively small amounts of data (on
the order of hundreds or thousands of rows, not tens of thousands), so you may
have to use the <code class="highlighter-rouge">LIMIT</code> command that we used when querying the Europeana
endpoint to reduce the number of results that you get back, just to keep the
software from freezing.</p>

<h1 id="further-reading">Further reading</h1>

<p>In this tutorial we got a look at the structure of LOD as well as a real-life
example of how to write SPARQL queries for the British Museum’s database. You
also learned how to use aggregation commands in SPARQL to group, count, and sort
results rather than simply list them.</p>

<p>There are even more ways to modify these queries, such as introducing <code class="highlighter-rouge">OR</code> and
<code class="highlighter-rouge">UNION</code> statements (for describing conditional queries), and <code class="highlighter-rouge">CONSTRUCT</code>
statements (for inferring new links based on defined rules), full-text
searching, or doing other mathematical operations more complex than counting.
For a more complete rundown of the commands available in SPARQL, see these
links:</p>

<ul>
  <li><a href="http://rdf.myexperiment.org/howtosparql?">How to SPARQL</a></li>
  <li><a href="http://en.wikibooks.org/wiki/XQuery/SPARQL_Tutorial">Wikibooks SPARQL tutorial</a></li>
</ul>

<p>Both the Europeana and Getty Vocabularies LOD sites also offer extensive, and
quite complex example queries which can be good sources for understanding how to
search their data:</p>

<ul>
  <li><a href="http://labs.europeana.eu/api/linked-open-data-SPARQL-endpoint">Europeana SPARQL how-to</a></li>
  <li><a href="http://vocab.getty.edu/queries">Getty Vocabularies Example Queries</a></li>
</ul>

	        </div>

            

	        <div class="author-info">
	   	        <p class="author-name">About the author</p>
			    <div class="author-description"><p>
                
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                       Matthew Lincoln is a PhD candidate at the University of Maryland, College Park. He is interested in the potential for computer-aided analysis of cultural datasets to help model long-term artistic trends in iconography, art markets, and social relations between artists in the early modern period.
&nbsp;
                   
                   
                   
                   
		        </p>
			    </div>
	        </div>
          <div class="citation-info">
            <p class="citation-head">Suggested Citation</p>
            <div class="suggested-citation">
              <p>
              
  
        Matthew Lincoln
  
  , 
              "Using SPARQL to access Linked Open Data," 
              <em>Programming Historian</em> 
              (24 November 2015), 
              http://programminghistorian.org/lessons/graph-databases-and-SPARQL
              </p>
            </div>
          </div>
        </article>
    </div>

    </div> <!-- end below-nav -->

<footer role="contentinfo">

          <div class="additional">
          <ul id="menu-main-menu" class="additional">
            <li class="menu-item"><a href="../index.html">About</a></li>
            <li class="menu-item"><a href="index.html">Lessons</a></li>
            <li class="menu-item"><a href="../contribute.html">Contribute</a></li>
            <li class="menu-item"><a href="../project-team.html">Project Team</a></li>
            <li class="menu-item"><a href="../blog.html">Blog</a></li>
          </ul>
        </div>


<p><em>The Programming Historian</em> ISSN 2397-2068, is released under the <a href="http://creativecommons.org/licenses/by/2.0/" rel="license">CC-BY</a> license.</p>
<p>The project is published by the <em>Editorial Board of the Programming Historian</em>, and first appeared in July 2012. It was last updated on 20 March 2016.</p>
<p class="github">
        <a href="https://github.com/programminghistorian/jekyll">Hosted on GitHub <img src="../images/GitHub-Mark-32px.png" title="GitHub logo"></a> 
		<a href="https://github.com/programminghistorian/jekyll/commits/gh-pages/lessons/graph-databases-and-SPARQL.md">Previous Versions</a>&nbsp;&#183;&nbsp;
		<a href="../feedback.html">Give Feedback</a>
</p>

</footer>


    </body>
</html>
